---
layout: beatrice_page
title: "Implementing Variable Fonts" 
permalink: /implementing-variable-fonts/
---
<h1>{{ page.title }}</h1>
<section class="content-section">
  <h2>Learn by doing</h2>
  <blockquote class="right">
    <p>Variable fonts are well supported and ready to use in production today</p>
  </blockquote>
  <p>The best way to understand variable fonts is to jump in and start playing with them. And there’s no need to wait—there are lots of ways you can put variable fonts to work in your projects today and <a href="https://caniuse.com/#feat=variable-fonts">browser support is very high</a>. The <a href="https://developers.google.com/fonts/docs/css2">Google Fonts API</a> supports them as of v2, you can host them yourself if you have the font files, and soon you’ll be able to add them to your site through the regular Google Fonts user interface.</p>

  <h2>Google Fonts API</h2>

  <p>The new API for requesting fonts lets you request any of a <a href="https://developers.google.com/fonts/docs/css2#list_of_variable_fonts">growing number of variable fonts</a> in their catalog. The syntax is pretty flexible, and allows you to request a specific combination of axes, static values, and ranges. Because the Google Fonts developer documentation site is so comprehensive, here the focus will specifically be on working with variable font axis and range combinations so you have the greatest flexibility available when designing your project.</p>

  <h3>Making the request</h3>

  <p>After selecting a variable font to use via the API, the first thing you need to pay attention to is the changes in syntax from v1 to v2. Requesting Yanone Kaffeesatz as a variable font with a weight axis range of 200–700 looks like this:</p>

  <p><code>https://fonts.googleapis.com/css2?family=Yanone+Kaffeesatz:wght@200..700</code></p>

  <p>Let’s break down the parts of the request:</p>

  <p><code>css2?family=[font name]:[axis keyword]@[range (low)]..[range (high)]</code></p>

  <p>First, note that while the address endpoint is css2, specifying the font name is relatively unchanged from the previous version of the API. It’s after the colon that things change more dramatically. This is where the axis (or axes) are listed, followed by an “@” symbol, followed by values indicating the ranges requested. The API allows for individual values to be specified, but here the request uses the ‘[range (low)]..[range (high)]’ syntax to request the full weight range of 200 to 700. If you only require the weight to cover part of the available range, you can adjust the values accordingly and end up with a slightly smaller download.</p>

  <p>Once requested, you can specify any value within that range in your CSS. In the case of the weight axis, that corresponds to the standard <code>font-weight</code> attribute.</p>

  <pre class="css"><code class="prettyprint">
    p {
      font-weight: 350;
    }
    strong {
      font-weight: 575;
    }
  </code></pre>

  <p>Italics can be requested separately with the corresponding weight axis range, or as a combination (if available) of both upright and italic in the full requested range.</p>

  <p>Just italics with a weight range of 200-900</p>
  <p><code>https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@1,200..900</code></p>

  <p>Or both upright and italics in the same range</p>
  <p><code>https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,200..900;1,200..900</code></p>

  <p>There are detailed notes on the syntax <a href="https://developers.google.com/fonts/docs/css2#forming_api_urls">in the documentation</a>, but here are a couple of points to remember:</p>
  <ul>
    <li>Keep the axes listed in alphabetical order</li>
    <li>Keep corresponding value sets in numerical order</li>
  </ul>

  <h3>Range versus static point</h3>

  <p>This version of the API can serve both static and variable fonts—and indeed static instances of variable fonts. In other words, the same URL structure can retrieve the static fonts, a variable font range, or a variable font instance at a single specific value. Although in some cases it may be useful to request, say, only the 575 weight of a given typeface, the real benefits of using variable fonts often lie in using more of the available range, which is why that’s the focus of most of the demos on this site.</p>

  <p>Crimson Pro, static, normal weight</p>
  <p><code>https://fonts.googleapis.com/css2?family=Crimson+Pro:400</code></p>

  <p>Crimson Pro, variable, specific weight:</p>
  <p><code>https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@450</code></p>

  <p>Crimson Pro, variable, full weight range</p>
  <p><code>https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@200..900</code></p>

  <p>The first example above is closest to the syntax previously supported in the API. The second example includes the <code>wght</code> keyword with a specific weight listed after the “@” sign, indicating a static instance from the variable font. The third example is a request for the full weight range of the variable font.</p>

  <hr />

  <h2>Progressive enhancement and legacy browser support</h2>

  <p>In order to support the broadest set of browsers and devices, it’s important to set up your CSS with standard values first, and the variable styles within an @supports block. If you’re using the Google Fonts API, the good news is the API is smart enough to <a href="https://developers.google.com/fonts/docs/css2#legacy_browser_support">supply the static font files if the browser doesn’t support variable ones</a>—so all you have to do is manage the CSS side of the equation. If you’re hosting the fonts yourself, you simply have to add in a reference to the variable font family inside the @supports block as well. It might look something like this:</p>

  <pre class="css"><code class="prettyprint">
    p {
      font-synthesis: none;
      font-weight: normal;
    }
    strong {
      font-synthesis: none;
      font-weight: bold;
    }
    @supports (font-variation-settings: normal) {
      p {
        font-weight: 350;
      }
      strong {
        font-weight: 575;
      }
    }
  </code></pre>

  <p>By adding in the <code>font-synthesis: none</code> declaration, you ensure that browsers like Safari or Firefox won’t artificially bold or italicize the typeface, which can lead to unexpected and less-than-ideal results.</p>

  <hr />

  <h2>Performance</h2>

  <p>Whether serving the fonts yourself or using the Google Fonts service, there are steps you can take to guarantee the best possible performance on your site. It helps to understand a bit about the loading and rendering process. The basic flow goes something like this:</p>

  <ol>
    <li>Browser requests a page</li>
    <li>Browser downloads HTML & linked CSS</li>
    <li>Browser parses HTML and CSS</li>
    <li>Browser initiates download of any linked CSS assets (like fonts)</li>
    <li>Browser now waits up to 3 seconds before starting to render the page while waiting for web fonts to download
      <ol>
        <li>If the fonts arrive within 3 seconds, the page is rendered as it should be</li>
        <li>If the fonts have not fully loaded, the browser renders the page using fallback system fonts, re-rendering the page once the web fonts arrive</li>
      </ol>
    </li>
  </ol>

  <p>Ideally, the fonts load quickly and the page is rendered correctly the first time—but often that’s not the case, which brings us to the next scenario. The phenomenon of text being rendered in the fallback fonts and then rerendering with the proper ones is known as a Flash of Unstyled Text (FOUT).</p>

  <p>Given that the purpose of any site is generally to deliver content, FOUT should be preferred, and indeed hastened if possible. Introducing a delay of at least 3 seconds greatly increases the chances of users abandoning the process altogether and going elsewhere. The W3C actually introduced the ability to tell the browser how to behave in this scenario, and the Google Fonts service and API now support it too.</p> 

  <p>This comes in the form of an attribute called <code>font-display</code>. By providing a value of <code>swap</code>, we tell the browser to render the page right away with fallback fonts, and then redraw the page once the fonts have loaded. However, this is only part of the solution. The next step is to include a web font loader that will help provide the ability to style the fallback fonts during the loading process, thereby minimizing any reflow of content once the browser rerenders the page when the web fonts arrive. This requires some Javascript, but is a really worthwhile enhancement of the user experience.</p>

  <p>The first part of this solution is easy: simply append <code>&display=swap</code> to the API request. One of the requests above for Crimson Pro would then look like this:</p>

  <p><code>https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@200..900&display=swap</code></p>

  <p>You can learn more about what <code>font-display</code> does and what options it affords on the <a href="https://www.w3.org/TR/css-fonts-4/#font-display-desc">W3C specifications page</a> and on the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display">MDN Web Docs</a> site.</p>

  <p>To take your solution further, take a look at Bram Stein’s <a href="https://fontfaceobserver.com/">FontFaceObserver from Bram Stein</a>, or read more about font-loading performance in general in <a href="https://www.zachleat.com/web/css-tricks-web-fonts/">this post by Zach Leatherman</a>.</p>

</section>